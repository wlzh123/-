#include<iostream>
using namespace std;
#include<deque>
struct BinaryTreeNode{
    int data;
    BinaryTreeNode *left;
    BinaryTreeNode *right;

};

BinaryTreeNode *ConstructCore(int *startPreorder,int *endPreorder,
                             int *startInorder,int *endInorder){
    int rootValue=startPreorder[0];
    BinaryTreeNode *root=new BinaryTreeNode();
    root->data=rootValue;
    root->left=NULL;
    root->right=NULL;
    //递归先写结果在写过程
    if(startPreorder==endPreorder) {
        if(startInorder==endInorder)
            return root;
    }

    int* rootInorder=startInorder;
    while(rootInorder<=endInorder&& *rootInorder!=rootValue)
                        rootInorder++;
    int leftlengh=rootInorder-startInorder;
    int *leftPreorderEnd=startPreorder+leftlengh;

    if(leftlengh>0){
    root->left=ConstructCore(startPreorder+1,leftPreorderEnd,
                             startInorder,rootInorder-1);
    }
    if(leftlengh<endPreorder-startPreorder){
        root->right=ConstructCore(leftPreorderEnd+1,endPreorder,
                             rootInorder+1,endInorder);
    }
    return root;
}
BinaryTreeNode *Construct(int *preorder,int *inorder,int length){
    if(preorder==NULL||inorder==NULL||length<=0)
        return NULL;
    return ConstructCore(preorder,preorder+length-1,inorder,inorder+length-1);
    //return Construct(preorder,preorder+int*((length-1)*4),inorder,int*((inorder-1)*4))
}
////按行打印二叉树
void PrintTreeNode(BinaryTreeNode *root,deque<BinaryTreeNode*> Q){
    Q.push_front(root);
  while(!Q.empty()){
    root=Q.front();
    Q.pop_front();
    cout<<root->data<<" ";
    if(root->left) Q.push_back(root->left);
     if(root->right) Q.push_back(root->right);
  }
}
int main(){
   deque<BinaryTreeNode*> deq;
   int pre[]={1,2,4,7,3,5,6,8};
   int mid[]={4,7,2,1,5,3,8,6};
   BinaryTreeNode *root =Construct(pre,mid,8);
   PrintTreeNode(root,deq);
}
